/* Copyright 2017 Ladybug Tools authors. MIT License */


	function getBuildingData() {

console.log( '', theBuilding.mesh );

		theBuilding.surfaceCount = 1;
		theBuilding.spaceCount = 1;
		theBuilding.openingCount = 1;
		theBuilding.shadeCount = 1;
		theBuilding.area = 0;

		initExportGbxml();

		getBuildingStoreys();

		getSurfaces();

		getAdjacentBuildings();

//console.log( 'json', json.gbXML );

		divJson = document.body.appendChild( document.createElement( 'div' ) );
		divJson.style.cssText = 'height: 90%; width: 800px; position: absolute; right: 30px; top: 20px; z-index: 1;' ;
		divJson.innerHTML = '<textarea id=txtJson style=height:100%;width:100%; >' + JSON.stringify( json, null, 4 ) + '</textarea>';

	}



	function initExportGbxml() {

		json = {

			gbXML: {
					"@xmlns": "http://www.gbxml.org/schema",
					"@xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
					"@xsi:schemaLocation": "http://www.gbxml.org/schema http://gbxml.org/schema/6-01/GreenBuildingXML_Ver6.01.xsd",
					"@xmlns:xhtml": "http://www.w3.org/1999/xhtml",
					"@xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
					"@useSIUnitsForResults": "true",
					"@SurfaceReferenceLocation": "Centerline",
					"@temperatureUnit": "F",
					"@lengthUnit": "Feet",
					"@areaUnit": "SquareFeet",
					"@volumeUnit": "CubicFeet",
					"@version": "6.01",

				Campus: {

					"@id" : "Facility",
					DaylightSavings: true,
					Description: 'Generated by tools from www.Ladybug.Tools/Spider/',


					Location: {
						CADModelAzimuth: 0,
						Elevation: 0,
						Latitude: 37.796,
						Longitude: -122.398,
						Name: 'Financial District Redevelopment Area',
						ZipcodeOrPostalCode: 94111
					},

					Building: {
						"@id": 1,
						"@buildingType": "Office",
						Name: 'theBuilding ' + theBuilding.footprint + ' shape',
						Area: 999999,
						BuildingStorey: [],
						Space: []
					},

					Surface: [],

				},
				Zone: [],
				DocumentHistory: []

			}

		}

/*

// area and volume need figuring out. Are they givens or calculated at run time?

		campus.buildingId = 1;
		campus.cadModelAzimuth = 0;
		campus.elevation = 000000;
		campus.locationName = 'San Francisco CA United States';
		campus.streetAddress = '440 Davis Court';

*/

	}



	function getBuildingStoreys() {

		const storeys = json.gbXML.Campus.Building.BuildingStorey;

		for ( let i = 0; i < theBuilding.storeys; i++ ) {

			const storey = storeys[ i ];

			const obj = {

					"@id": "storey-" + ( i + 1 ),
					Name: "storey " + ( i + 1 ),
					Level: ( i * theBuilding.storeyHeight )

				}

			storeys.push( obj );

		}


	}


// tbd: break up into smaller functions

	function getSurfaces() {

//console.log( 'storey', theBuilding.group.children[ 0 ] );

		const surfaces = json.gbXML.Campus.Surface;
		const spaces = json.gbXML.Campus.Building.Space;
		const zones = json.gbXML.Zone;

		let surfaceCount = theBuilding.surfaceCount;
		let spaceCount; //  = theBuilding.spaceCount;
		let openingCount = theBuilding.openingCount;
		let shadeCount = theBuilding.shadeCount;

		const storeys = theBuilding.group.children;


		for ( let i = 0; i < storeys.length; i++ ) {

			const storey = storeys[ i ];
			const storeyCount = i + 1;
			theBuilding.storeyCount = storeyCount;

			const slabs = storey.children[ 0 ];
			const slabsPerStory = slabs.children.length;
			theBuilding.slabsPerStory = slabsPerStory;

			for ( let j = 0; j < slabsPerStory; j++ ) {

				const slab = slabs.children[ j ];

				const slabGeometry = new THREE.Geometry().fromBufferGeometry( slab.geometry );
//console.log( 'slabGeometry', slabGeometry  );

				const area = THREE.ShapeUtils.area( slabGeometry.clone().vertices.reverse() );
				theBuilding.area += area;
//console.log( 'area', theBuilding.area );
//console.log( 'area', area.toLocaleString() );
//console.log( 'volume', ( area * theBuilding.storeyHeight ).toLocaleString() );

				const type = storeyCount === theBuilding.storeys ? 'slabRoof' : 'slabCeiling';

				let surfaceSlab = getSlabType( type, storeyCount, surfaceCount, theBuilding.spaceCount );

				let delta = j === slabsPerStory - 1 ? 5 : 0; // un-exaggerate interior floor elevation
				const ceiling = slab.clone();
				ceiling.geometry = slab.geometry.clone();
				ceiling.geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, theBuilding.storeyHeight + delta ) );
				ceiling.geometry.verticesNeedUpdate = true;

//console.log( '', slab );

				getPolyLoop2( surfaceSlab, ceiling );

				surfaceCount ++;

				surfaces.push( surfaceSlab );

				if ( storeyCount === 1 ) {

					slabOnGrade = slab.clone();

					if ( j === slabsPerStory - 1 ) {

						slabOnGrade.geometry = slab.geometry.clone();
						slabOnGrade.geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0, delta ) );
						slabOnGrade.geometry.verticesNeedUpdate = true;

					}

					surfaceSlab = getSlabType( 'slabOnGrade', storeyCount, surfaceCount, theBuilding.spaceCount );

					getPolyLoop2( surfaceSlab, slabOnGrade );

					surfaceCount ++;

					surfaces.push( surfaceSlab );

//					addSpaceAndZone( area );

				}

				addSpaceAndZone( area );

			}


			const interiorWalls = storey.children[ 1 ];

			spaceCount = i * slabsPerStory + 1;

			for ( let j = 0; j < interiorWalls.children.length; j++ ) {

				const interiorWall = interiorWalls.children[ j ];

				const surfaceInteriorWall = {

					"@surfaceType": "InteriorWall",
					"@id": "surface-" + surfaceCount,
					Name: 'storey-' + ( i + 1 ) + '-' + interiorWall.name + '-space-' + spaceCount,
					RectangularGeometry: {
						Azimuth: interiorWall.userData.angle
					},
					CADOjectId: "none",
					AdjacentSpaceId: [
						{ "@spaceIdRef": "space-" + ( i * slabsPerStory + slabsPerStory ) },
						{ "@spaceIdRef": "space-" + spaceCount },
					],
					PlanarGeometry: {
						PolyLoop: []
					}

				};

				getPolyLoop2( surfaceInteriorWall, interiorWall );


				surfaces.push( surfaceInteriorWall );

				surfaceCount ++;
				spaceCount ++;

			}


			const interiorWallsDiagonal = storey.children[ 2 ];

			spaceCount = i * slabsPerStory + 1;

			const len = interiorWallsDiagonal.children.length;

			for ( let j = 0; j < len ; j++ ) {

					const interiorDiagonalWall = interiorWallsDiagonal.children[ j ];

					const surfaceInteriorDiagonalWall = {

						"@surfaceType": "InteriorWall",
						"@id": "surface-" + surfaceCount,
						Name: 'storey-' + ( i + 1 ) + '-' + interiorDiagonalWall.name + '-space-' + spaceCount,
						RectangularGeometry: {
							Azimuth: interiorDiagonalWall.userData.angle
						},
						CADOjectId: "none",
						AdjacentSpaceId: [
							{ "@spaceIdRef": "space-" + ( j < len - 1 ? spaceCount + 1 : ( i * slabsPerStory + 1 ) ) },
							{ "@spaceIdRef": "space-" + spaceCount }
						],
						PlanarGeometry: {
							PolyLoop: []
						}

					};

					getPolyLoop2( surfaceInteriorDiagonalWall, interiorDiagonalWall );

					surfaces.push( surfaceInteriorDiagonalWall );

					surfaceCount ++;
					spaceCount ++;

				}


			const exteriorWalls = storey.children[ 3 ];

			spaceCount = i * slabsPerStory + 1;

			for ( let j = 0; j < exteriorWalls.children.length; j++ ) {

				const exteriorWall = exteriorWalls.children[ j ];

				const surfaceExteriorWall = {

					"@surfaceType": "ExteriorWall",
					"@id": "surface-" + surfaceCount,
					Name: 'storey-' + ( i + 1 ) + '-' + exteriorWalls.children[ j ].name + '-space-' + spaceCount,
					RectangularGeometry: {
						Azimuth: exteriorWalls.children[ j ].userData.angle
					},
					CADOjectId: "none",
					AdjacentSpaceId: {
						"@spaceIdRef": "space-" + spaceCount
					},
					PlanarGeometry: {
						PolyLoop: []
					},
					Opening: []

				};

				getPolyLoop2( surfaceExteriorWall, exteriorWall );

				addOpenings( surfaceExteriorWall, exteriorWall );

				surfaces.push( surfaceExteriorWall );

				surfaceCount ++;

				addOverHangsFins( surfaces, exteriorWall );

				spaceCount ++;

			}

		}

		json.gbXML.Campus.Building.Area = theBuilding.area.toLocaleString();

	}



	function addSpaceAndZone( area ) {

		const spaces = json.gbXML.Campus.Building.Space;
		const zones = json.gbXML.Zone;

		const space = {

			"@id": "space-" + theBuilding.spaceCount,
			"@zoneIdRef": "zone-" + theBuilding.spaceCount,
			"@buildingStoreyIdRef": 'storey-' + theBuilding.storeyCount,
			"@conditionType": "HeatedAndCooled",
			Name: 'storey-' + theBuilding.storeyCount + '-space-' + theBuilding.spaceCount,
			Description: "internal space " + theBuilding.spaceCount,
			Area: area.toLocaleString(),
			Volume: ( area * theBuilding.storeyHeight ).toLocaleString()

		};

		spaces.push( space );

		const zone = {

			"@id": "zone-" + theBuilding.spaceCount,
			Name: 'storey-' + theBuilding.storeyCount + '-zone-' + theBuilding.spaceCount

		};

		zones.push( zone );

		theBuilding.spaceCount ++;


	}



	function getSlabType( type, storey, surfaceCount, spaceCount ) {

		const slab = {

			slabOnGrade: {

				"@surfaceType": "SlabOnGrade",
				"@id": "surface-" + surfaceCount,
				Name: 'storey-' + storey + '-slabongrade-space-' + spaceCount,
				RectangularGeometry: {
					Azimuth: 90
				},
				CADOjectId: "none",
				AdjacentSpaceId: { "@spaceIdRef": "space-" + spaceCount },
				PlanarGeometry: {
					PolyLoop: []
				}

			},
			slabCeiling: {

				"@surfaceType": "Ceiling",
				"@id": "surface-" + theBuilding.surfaceCount,
				Name: 'storey-' + storey + '-ceiling-space-' + spaceCount,
				RectangularGeometry: {
					Azimuth: 90
				},
				CADOjectId: "none",
				AdjacentSpaceId: [
					{ "@spaceIdRef": "space-" + spaceCount },
					{ "@spaceIdRef": "space-" + ( spaceCount + theBuilding.slabsPerStory ) }
				],
				PlanarGeometry: {
					PolyLoop: []
				}

			},
			slabRoof: {

				"@surfaceType": "Roof",
				"@id": "surface-" + surfaceCount,
				Name: 'storey-' + storey + '-roof-space-' + spaceCount,
				RectangularGeometry: {
					Azimuth: 90
				},
				CADOjectId: "none",
				AdjacentSpaceId: { "@spaceIdRef": "space-" + spaceCount },
				PlanarGeometry: {
					PolyLoop: []
				}

			}
		};

		return slab[ type ];

	}



	function getPolyLoop2( surface, mesh ) {

// this function works OK but creates too many CartesianPoint elements.
// See checkGbxmlData below for temporary search and replace fix

//console.log( 'surface', surface );
//console.log( 'mesh.geo', mesh.geometry );

		const meshNewGeometry = new THREE.Geometry().fromBufferGeometry( mesh.geometry );
		const vertices = [];
		const len = mesh.name.startsWith( 'exterior-wall' ) ? 4 : meshNewGeometry.vertices.length;
//console.log( mesh.name, len );

		for ( let k = 0; k < len; k++ ) {

			const vector = meshNewGeometry.vertices[ k ].clone();
			vertices.push( mesh.localToWorld( vector ) );

		}

		mesh.userData.verticesWorld = vertices;

//console.log( 'vertices', vertices );

		const cartesianPoint = [];

		for ( let i = 0; i < vertices.length; i++ ) {

			vertex = vertices[ i ];

			const point = { CartesianPoint: [

				{ Coordinate: Number( vertex.x.toFixed( 4 ) ) },
				{ Coordinate: Number( vertex.y.toFixed( 4 ) ) },
				{ Coordinate: Number( vertex.z.toFixed( 4 ) ) }

			] };

			surface.PlanarGeometry.PolyLoop.push( point );

		}

	}



	function addOpenings( surface, mesh ) {

//console.log( 'wall', mesh );

		for ( var i = 0; i < mesh.userData.holes.length; i++ ) {

			holes = mesh.userData.holes[ i ];

			let opening = {
				"@openingType": "FixedWindow",
				"@id": "opening-" + theBuilding.openingCount,
				RectangularGeometry: {
					Azimuth: mesh.userData.angle
				},
				PlanarGeometry: {
					PolyLoop: []
				}
			};

			for ( let j = 0; j < 4; j++ ) {

				const vector = holes[ j ].clone();
				const vertex = mesh.localToWorld( vector );
				const point = { CartesianPoint: [

					{ Coordinate: Number( vertex.x.toFixed( 4 ) ) },
					{ Coordinate: Number( vertex.y.toFixed( 4 ) ) },
					{ Coordinate: Number( vertex.z.toFixed( 4 ) ) }

				] };

				opening.PlanarGeometry.PolyLoop.push( point );

			}

			surface.Opening.push( opening );

			theBuilding.openingCount ++;

		}

	}



	function addOverHangsFins( surfaces, mesh ) {

//console.log( 'wall', mesh );

		mesh.traverse( function ( child ) {

			if ( child.name.startsWith( 'overhang-' ) || child.name.startsWith( 'fin-' ) ) {

//console.log( 'child.name',child.name );

				let surface = {
					"@surfaceType": "Shade",
					"@id": "shade-" + theBuilding.shadeCount,
					"Name": child.name,
					"RectangularGeometry": {
						"Azimuth": mesh.userData.angle
					},
					"PlanarGeometry": {
						"PolyLoop": []
					}
				};

				getPolyLoop2( surface, child  );

				surfaces.push( surface );

				theBuilding.shadeCount ++;

			}

		} );


	}



	function getAdjacentBuildings() {

		const surfaces = json.gbXML.Campus.Surface;

		for ( let child of scene.children ) {

			if ( child.name.startsWith( 'building-adjacent' ) ) {

				const geometry = new THREE.Geometry().fromBufferGeometry( child.geometry.clone() );

				let vertexCount = 0;

				for ( let i = 0; i < 5; i++ ) {

					const surface = {
						"@surfaceType": "Shade",
						"@id": "shade-" + theBuilding.shadeCount,
						Name: child.name,
						RectangularGeometry: {
							Azimuth: 90 // child.userData.angle
						},
						PlanarGeometry: {
							PolyLoop: []
						}
					};

					const v1 = child.localToWorld ( geometry.vertices[ vertexCount++ ] );
					const v2 = child.localToWorld ( geometry.vertices[ vertexCount++ ] );
					const v3 = child.localToWorld ( geometry.vertices[ vertexCount++ ] );
					const v4 = child.localToWorld ( geometry.vertices[ vertexCount++ ] );

					const vertices = [ v2, v1, v3, v4 ];

					for ( let j = 0; j < 4; j++ ) {

						const cartesianPoint = [];
						let vertex = vertices[ j ];

						const point = { CartesianPoint: [

								{ Coordinate: Number( vertex.x.toFixed( 4 ) ) },
								{ Coordinate: Number( vertex.y.toFixed( 4 ) ) },
								{ Coordinate: Number( vertex.z.toFixed( 4 ) ) }

							]

						};

						surface.PlanarGeometry.PolyLoop.push( point );

					}

					surfaces.push( surface );

					theBuilding.shadeCount ++;

				}

			}

		}

	}



/////////////////


https://developer.mozilla.org/en-US/docs/Archive/JXON#Reverse_Algorithms


	function createXML ( oObjTree ) {

		function loadObjTree (oParentEl, oParentObj) {

			var vValue, oChild;

			if ( oParentObj.constructor === String || oParentObj.constructor === Number || oParentObj.constructor === Boolean ) {

				oParentEl.appendChild(oNewDoc.createTextNode(oParentObj.toString())); /* verbosity level is 0 or 1 */

				if ( oParentObj === oParentObj.valueOf()) { return; }

			} else if ( oParentObj.constructor === Date) {

				oParentEl.appendChild(oNewDoc.createTextNode(oParentObj.toGMTString()));

			}

			for ( var sName in oParentObj ) {

			if ( isFinite(sName)) { continue; } /* verbosity level is 0 */

				vValue = oParentObj[sName];

				if ( sName === "keyValue") {

					if ( vValue !== null && vValue !== true) {

						oParentEl.appendChild(oNewDoc.createTextNode(vValue.constructor === Date ? vValue.toGMTString() : String(vValue)));

					}

				} else if ( sName === "keyAttributes") { /* verbosity level is 3 */

					for ( var sAttrib in vValue) { oParentEl.setAttribute(sAttrib, vValue[sAttrib]); }

				} else if ( sName.charAt(0) === "@") {

					oParentEl.setAttribute(sName.slice(1), vValue);

				} else if ( vValue.constructor === Array ) {

					for ( var nItem = 0; nItem < vValue.length; nItem++ ) {

						oChild = oNewDoc.createElement(sName );
						loadObjTree(oChild, vValue[nItem]);
						oParentEl.appendChild(oChild);

					}

				} else {

					oChild = oNewDoc.createElement(sName);

					if ( vValue instanceof Object ) {

						loadObjTree( oChild, vValue);

					} else if ( vValue !== null && vValue !== true ) {

						oChild.appendChild(oNewDoc.createTextNode( vValue.toString() ) );
//						oChild.innerHTML += oNewDoc.createTextNode( vValue.toString());

					}

					oParentEl.appendChild( oChild);

				}

			}

		}

		const oNewDoc = document.implementation.createDocument( "", "", null);

		loadObjTree( oNewDoc, oObjTree );

		return oNewDoc;

	}



	function checkGbxmlData() {

		if ( !json ){ alert( 'get building data first' ); return; }

		divGbxml = document.body.appendChild( document.createElement( 'div' ) );
		divGbxml.style.cssText = 'height: 90%;  width: 800px; position: absolute; right: 50px; top: 50px; z-index: 2; ' ;
		divGbxml.innerHTML = '<textarea id=txtGbxml style=height:100%;width:100%; ></textarea>';

		gbxml = createXML ( json );

//console.log( 'gbxml', gbxml  );

// https://stackoverflow.com/questions/9898698/convert-xml-to-string-and-append-to-page

		const xmlText = new XMLSerializer().serializeToString( gbxml );
		const xmlTextNode = document.createTextNode( xmlText );

		txtGbxml.appendChild( xmlTextNode );

// the kludge to get around getPolyLoop fail

		re = /\<\/CartesianPoint>\<CartesianPoint>/gi;

		txtGbxml.value = txtGbxml.value.replace( re, '' )

		re = /\<\/PolyLoop>\<PolyLoop>/gi;

		txtGbxml.value = txtGbxml.value.replace( re, '' )

		txtGbxml.value = formatXml( txtGbxml.value );



	}



	function formatXml(xml) {

// https://gist.github.com/sente/1083506/d2834134cd070dbcc08bf42ee27dabb746a1c54d

		const PADDING = ' '.repeat( 4 ); // set desired indent size here
		const reg = /(>)(<)(\/*)/g;
		let pad = 0;

		xml = xml.replace( reg, '$1\r\n$2$3' );

		return xml.split('\r\n').map(( node, index ) => {

			let indent = 0;

			if (node.match(/.+<\/\w[^>]*>$/)) {

				indent = 0;

			} else if (node.match(/^<\/\w/) && pad > 0) {

				pad -= 1;

			} else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {

				indent = 1;

			} else {

				indent = 0;

			}

			pad += indent;

			return PADDING.repeat(pad - indent) + node;

		}).join('\r\n');

	}



	function saveFile() {

		if( !gbxml ) { alert( 'Get some building data first.' ); return; }

		let blob;

		blob = new Blob( [ txtGbxml.value ] );

		let a = document.body.appendChild( document.createElement( 'a' ) );
		a.href = window.URL.createObjectURL( blob );
		const fileName = theBuilding.footprint.toLowerCase() + '-' + theBuilding.area + 'area-' + theBuilding.storeys + 'flr-' + theBuilding.orientation + 'deg' + '.xml';
		a.download = fileName;

		a.click();

//		delete a;
		a = null;

		if ( window.checkWindow !== undefined ) { window.checkWindow.close(); }

	}
