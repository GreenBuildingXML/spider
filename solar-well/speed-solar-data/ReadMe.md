
# Solar Shadow Range Analysis and Raditation test gbXML file and results data file instructions


## [speed result viewer 1]( http://www.ladybug.tools/spider/solar-well/speed-solar-data/speed-result-viewer-1.html )



Summary: Previously we evaluated using mesh points, vectors, and analysis values output from ladybug shadow range and solar radiation code to feed back into a three.js scene for visualization. After further thought, this workflow has changed for several reasons. First, it was discovered that Mostapha's code meshes all internal walls, floors, and ground plane areas underneath shading buildings and the main building. This resulted in an unecessarily large number of mesh points and computational overhead. Additionally, while each mesh is generated with a given value of grid size (1m2 in our case), as all the surfaces are different sizes (length and width) it resulted in points very close to the surface edges, meaning that when it was passed back to Theo to visualize the points and their associated analysis values (without the actual geometry as well) it resulted in many serrated edges. Keeping this format would require Theo to determine if a grid point mesh area (the 1m2 centered at the mesh point) went outside the boundary of the polyloop of the surface, and split it so no colored meshes showed up beyond the surface boundary. Furthermore, it was determined that if the meshes were generated by Theo using the gbXML surfaces first, then passed to Mostapha's shadow range and solar radiation code, then we'd have more control over the visualization of the results. Therefore we created the following workflow....

While our geometry starts as raw three.js geometry in the SPEED GUI, we will first generate a gbXML file using our existing code on node.js. This is because we have a need in some parts of the code to know the polyloops for shading surfaces for calculation of shadow masking. Using this gbXML file (which will be generated in either IP or SI), Theo will mesh the follow surfaces:

1. Shadow Range Analysis: (1) The ground plane except the parts beneath the main building and shading buildings and (2) all exterior wall and roof surfaces for the main building. No meshes will be made for other shading surfaces such as overhangs, fins, and adjacent buildings. The ground plane which will be defined as a shading surface in the gbXML file. This surface can be seen in        SPEEDTest.xml as "surfaceType="Shade", id="shade-9", Name=Ground". We will be adding the logic on how to size this ground plane. This ground plane will have to be reconciled with the existing ground plane that is able to be toggled on and off in the gbXML Viewer.

2. Solar Radiation Analysis: (1) The ground plane except the parts beneath the main building and shading buildings and (2) all exterior wall and roof surfaces for the main building and any adjacent building. 

The mesh density for each surface may be different so that the mesh points generated are an evenly distributed set of points when overlayed on the base geometry. The mesh size should be as close to 1m2 (or equivalent IP) as possible. It can be slightly larger or slightly smaller in order to generate the evenly distributed grid based on the specific length and width of the surface. This way when the mesh points and vectors and their associated analysis values are read back into three.js and visualized, they will essentially re-create the gbXML surface exactly.
           
The mesh points and vectors that are generated will be exported to a file called SPEEDmeshes.shadowinput and SPEEDMeshes.radiationinput. Note the number of mesh points will be different in each case since the shading surfaces are meshed for radiation and not shadow range. Along with the x,y,z coordinates of each point and the 3 vector coordinates, the surface id of the parent surface will also be exported to these files for debugging purposes (shade-XX, surface-XX). The example files for the file format are SPEEDMeshesExample.shadowinput and SPEEDMeshesExample.radiationinput. The first string is the surface id, the second, third, and fourth are the x,y,z coordinates, respectively, the fifth, sixth, and seventh values are the x,y,z vector coordinates, and the eighth value is the grid size associated with the mesh point.

Using this file, we will run a modified version of Mostapha's ladybug code that is independent of Rhino/GH. For now it will remain a series of python scripts with the appropriate node.js dependencies defined. The output for the shadow range and solar radiation analysis will be the same format as the input files, but with a ninth value appended to each line item, corresponding to either the hours of sunlight for the shadow range analysis or the cumulative solar radiation values. The files will be called SPEEDmeshes.shadowoutput and SPEEDMeshes.radiationoutput. The example files for the file format are SPEEDMeshesExample.shadowoutput and SPEEDMeshesExample.radiationoutput. 

These files will be read in, parsed, and visualized in three.js (maybe the gbXML viewer?). Only the grid mesh areas and analysis value will be displayed (i.e. no points or vectors), though a toggle may added to the viewer to display them if desired. It is not required.

#Legend and Color-Coding Scheme#

With each analysis visualization, a corresponding legend must be generated. A visual example of what the legend should look like for solar radiation can be found in SolarRadiation_Summer_AllDays_Plan.jpg and for shadow range in ShadowRange_Annual_15_Plan.jpg. Ladybug uses 11 different colors for both the shadow range and solar radiation legends. We'd like to use the same number of color bins and the same colors as they are fairly conventional in other tools. When reading in the .shadowoutput and .radiationoutput files, the max value should be determined for analysis value, and the bins descretized accordingly ((max value-0)/12). Hour values for shadow range will always be whole integers, not rounding needed. Radiation values should be rounding to the nearest tenth decimal (not hundredth as shown in the images). 

---------
First is a test gbXML file we are using for the shadow range analysis and radiation analysis. Simple box, one window each side, overhangs and fins south side, and an adjacent building. We also will be writing out a ground plane as a shading surface to generate the ground mesh based on the size of the building as a single story building (basically 5 times as large as the longest side in both dimensions). We determined this size is enough to capture the farthest casting shadows. You will see it as shading.9 in the gbXML file.

it can be imported into the gbXML viewer
we took this gbXML, imported into Rhino and Grasshopper, and figured out all the settings we needed to run the shadow range analysis and solar radiation in ladybug. We identififed the ideal mesh size, size of ground plan relative to building, and reasonable computational times using partial analysis for shadows to represent months
we then output the results into two files we custom formatted
The first is the results file .shadow and next .radiation. It shows the x,y,z coordinates of all the mesh points, their vectors, then then the seventh value is the # of sunlight hours for the given time range for the .shadow file and the insolation value (kWh/m2) for each mesh point in the .radiation file.
The grid sizes we will keep the same between the two analyses
each took about 10-30 seconds to run based on the time period
(and I will put this all on Github too)
the mesh points are all currently offset from the actual plane of the gbXML geometry by 0.01m, since it's required in ladybug due to some weird thing in Rhino that ensures you're not calculating a point on the inside of a surface (i.e. wrong normal). We don't have to worry about that, but currently the components requires the offset, we won't in our code. We could subtract out 0.01m from every mesh point (in normal direction), but not necessary at this point I don't think.
We'd like  you to work your magic and take this results file and overlay on gbXML geometry in the viewer. In reality, for raditation, you only need the mesh points (and grid size, which is  1m2) and you could show the entire scene with result data since it doesn't show windows etc. and we mesh everything including adjacent building
but for shadow you'll want the geometry overlay
based on min and max values we will have to choose a color gradient for the lenged and grid mesh coloring
I'll send in the am images of what the visualizations look like in GH so you can see generally what we are targeting for effect and legend design. But of course we are not constrained to that gradient or color scheme. The shadow range analysis will always show the sun path analemma in the visualizaiton. The user will have the choice toggle on or off the analemma for the solar radiation
there is some post-processing to analysis results to do before visualizing. 
